---
title: Standard Template Library(STL)
description: A guide in my new Starlight docs site.
---


The C++ Standard Template Library (STL) provides a collection of container classes and algorithms that simplify the management of data structures and algorithms.

### 1. Array
    - Fixed-size container that stores elements of the same type.
    - Syntax: `std::array<T, N>` where `T` is the type, and `N` is the size.
    - Random access (O(1)).

##### Common Methods:
- `arr.size()`, `arr.front()`, `arr.back()`,` arr.at(i)`, `arr.fill(val)`

```c++
#include <array>
int main() {
    array<int, 5> arr = {1, 2, 3, 4, 5};
    cout << "First element: " << arr.front() << endl;
    cout << "Last element: " << arr.back() << endl;
    return 0;
}
```

### 2. Vector
    - Dynamic array that can resize itself.
    - Random access (O(1)) and amortized O(1) push-back operation.

##### Common Methods:

    - `vec.size()`,` vec.push_back(val)`, `vec.pop_back()`, `vec.front()`, `vec.back()`, `vec.at(i)`

```c++
#include <vector>
int main() {
    vector<int> vec = {1, 2, 3};
    vec.push_back(4);  // Adding element
    cout << "Size of vector: " << vec.size() << endl;
    vec.pop_back();  // Removing last element
    return 0;
}
```

### 3. Deque (Double-ended Queue)
    - Allows fast insertion and deletion from both ends (O(1) at both front and back).
    - More memory overhead than a vector.

##### Common Methods:
    - `dq.push_back()`, `dq.push_front()`, `dq.pop_back()`, `dq.pop_front()`

```c++
#include <deque>

int main() {
    std::deque<int> dq = {2, 3, 4};
    dq.push_front(1);  // Adds 1 at the front
    dq.push_back(5);   // Adds 5 at the back
    dq.pop_front();    // Removes first element
    dq.pop_back();     // Removes last element
    return 0;
}
```

### 4. List (Doubly Linked List)
    - Allows fast insertion and deletion at any point (O(1)), but no random access (O(n)).
    - Ideal for frequent insertions and deletions.

##### Common Methods:

    - `lst.push_back()`, `lst.push_front()`, `lst.pop_back()`, `lst.pop_front()`, `lst.insert()`

```c++
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3};
    lst.push_front(0);  // Adds 0 at the front
    lst.push_back(4);   // Adds 4 at the end
    for (int x : lst) {
        cout << x << " ";  // Prints 0 1 2 3 4
    }
    return 0;
}
```

### 5. Stack
    - LIFO (Last In, First Out) structure.
    - Implemented using deque or vector by default.
##### Common Methods:
    - `st.push()`, `st.pop()`, `st.top()`, s`t.empty()`, `st.size()`

```c++
#include <stack>

int main() {
    stack<int> st;
    st.push(1);
    st.push(2);
    st.push(3);
    while (!st.empty()) {
        cout << st.top() << " ";  // Prints elements in reverse order: 3 2 1
        st.pop();
    }
    return 0;
}
```

### 6. Queue
    - FIFO (First In, First Out) structure.
    - Implemented using deque or list.

##### Common Methods:

    - `q.push()`, `q.pop()`, `q.front()`, `q.back()`, `q.empty()`, `q.size()`

```c++
#include <queue>

int main() {
    queue<int> q;
    q.push(1);
    q.push(2);
    q.push(3);
    while (!q.empty()) {
        cout << q.front() << " ";  // Prints elements in order: 1 2 3
        q.pop();
    }
    return 0;
}
```

### 7. Priority Queue (Max-Heap by default)
    - A queue where elements are always sorted; by default, largest element has the highest priority (max-heap).
    - For min-heap, use `std::greater<int>`.

##### Common Methods:

    - `pq.push()`, `pq.pop()`, `pq.top()`, `pq.empty()`, `pq.size()`

```c++
#include <queue>

int main() {
    priority_queue<int> pq;
    pq.push(10);
    pq.push(5);
    pq.push(20);
    cout << "Top element: " << pq.top() << endl;  // Outputs 20
    pq.pop();
    cout << "Top element after pop: " << pq.top() << endl;  // Outputs 10
    return 0;
}
```

### 8. Set
    - Stores unique, sorted elements (by default, ascending).
    - Elements are ordered by a comparison function (O(log n) operations).

##### Common Methods:

    - `s.insert()`, `s.erase()`, `s.find()`, `s.size()`, `s.count()`

```c++
#include <set>

int main() {
    set<int> s = {1, 2, 3};
    s.insert(4);    // Inserts 4
    s.erase(2);     // Removes 2
    for (int x : s) {
        cout << x << " ";  // Prints 1 3 4
    }
    return 0;
}
```

### 9. Map
    - Stores key-value pairs where keys are unique and sorted (O(log n) operations).
    - Keys are ordered by a comparison function.

#### Common Methods:

    - `mp[key]`, `mp.insert()`, `mp.erase()`, `mp.find()`, `mp.size()`
```c++
#include <map>

int main() {
    std::map<int, string> mp;
    mp[1] = "Apple";
    mp[2] = "Banana";
    for (auto x : mp) {
        cout << x.first << ": " << x.second << endl;  // Prints: 1: Apple, 2: Banana
    }
    return 0;
}
```

### 10. STL Algorithms
    - Found in `<algorithm>` and `<numeric>` headers.
    - Work with all containers using iterators.

##### Common Algorithms:

    - `std::sort()`, `std::reverse()`, `std::binary_search()`, `std::max_element()`, `std::min_element()`, `std::accumulate()`

```c++
#include <vector>
#include <algorithm>

// sorting
int main() {
    vector<int> vec = {3, 1, 4, 1, 5};
    sort(vec.begin(), vec.end());  // Sorts in ascending order
    for (int x : vec) {
        cout << x << " ";  // Prints: 1 1 3 4 5
    }
    return 0;
}

// reversing
int main() {
    vector<int> vec = {1, 2, 3, 4, 5};
    std::reverse(vec.begin(), vec.end());  // Reverses the vector
    for (int x : vec) {
        cout << x << " ";  // Prints: 5 4 3 2 1
    }
    return 0;
}

// Binary Search
int main() {
    vector<int> vec = {1, 2, 3, 4, 5};
    bool found = std::binary_search(vec.begin(), vec.end(), 3);  // Search for 3
    cout << "3 found: " << found << endl;  // Outputs: 3 found: 1
    return 0;

// Max/min Elements
int main() {
    vector<int> vec = {1, 2, 3, 4, 5};
    auto max_elem = std::max_element(vec.begin(), vec.end());
    auto min_elem = std::min_element(vec.begin(), vec.end());
    cout << "Max: " << *max_elem << ", Min: " << *min_elem << endl;  // Outputs: Max: 5, Min: 1
    return 0;
}

// Accumulate
int main() {
    vector<int> vec = {1, 2, 3, 4, 5};
    int sum = std::accumulate(vec.begin(), vec.end(), 0);  // Sum of all elements
    cout << "Sum: " << sum << endl;  // Outputs: Sum: 15
    return 0;
}

```